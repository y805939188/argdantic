{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Argdantic Typed command line interfaces, powered by argparse and pydantic . Features argdantic provides a thin boilerplate layer to provide a modern CLI experience, including: Typed arguments: arguments require full typing by default, enforcing clarity and help your editor provide better support (linting, hinting). Nested models: exploit pydantic models to scale from simple primitives to complex nested configurations with little effort. Nested commands: combine commands and build complex hierarchies to build complex interfaces. Validation by default: thanks to pydantic , field validation is provided by default, with the desired complexity. Multiple sources: arguments can be provided from multiple sources, including environment variables, JSON, TOML and YAML files. Quickstart Installation Installing argdantic can be done from source, or simply using pip . The only required dependency is, of course, pydantic , while the remaining can be selected depending on your needs: recommended choice: install everything this includes orjson, pyyaml, tomli, python-dotenv user@pc:~$ pip install argdantic [ all ] env, json, toml or yaml dependencies user@pc:~$ pip install [ env | json | toml | yaml ] minimum requirement, only pydantic included user@pc:~$ pip install argdantic A Simple Example Creating a CLI with argdantic can be as simple as: from argdantic import ArgParser # 1. create a CLI instance parser = ArgParser () # 2. decorate the function to be called @parser . command () def buy ( name : str , quantity : int , price : float ): print ( f \"Bought { quantity } { name } at $ { price : .2f } .\" ) # 3. Use your CLI by simply calling it if __name__ == \"__main__\" : parser () Then, in a terminal, the help command can provide the usual information: $ python cli.py --help > usage: buy [-h] --name TEXT --quantity INT --price FLOAT > > optional arguments: > -h, --help show this help message and exit > --name TEXT > --quantity INT > --price FLOAT This gives us the required arguments for the execution: $ python cli.py --name apples --quantity 10 --price 3 .4 > Bought 10 apples at $3.40. Acknowledgements This project is heavily inspired by other awesome works, including: click : the most popular CLI library for Python for complex applications, the best alternative to argparse . typer : based on click , a great project that inspired the creation of argdantic . It is a great alternative, however it does not support pydantic models at the moment. pydantic-cli : a mature project that provides a similar experience to argdantic , however it does not support nested models, commands and different sources. Do you like argdantic , but prefer click as a CLI library? Check out clidantic , a twin project that uses click instead of argparse . License This project is licensed under the terms of the MIT license. Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Home"},{"location":"#argdantic","text":"Typed command line interfaces, powered by argparse and pydantic .","title":"Argdantic"},{"location":"#features","text":"argdantic provides a thin boilerplate layer to provide a modern CLI experience, including: Typed arguments: arguments require full typing by default, enforcing clarity and help your editor provide better support (linting, hinting). Nested models: exploit pydantic models to scale from simple primitives to complex nested configurations with little effort. Nested commands: combine commands and build complex hierarchies to build complex interfaces. Validation by default: thanks to pydantic , field validation is provided by default, with the desired complexity. Multiple sources: arguments can be provided from multiple sources, including environment variables, JSON, TOML and YAML files.","title":"Features"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#installation","text":"Installing argdantic can be done from source, or simply using pip . The only required dependency is, of course, pydantic , while the remaining can be selected depending on your needs: recommended choice: install everything this includes orjson, pyyaml, tomli, python-dotenv user@pc:~$ pip install argdantic [ all ] env, json, toml or yaml dependencies user@pc:~$ pip install [ env | json | toml | yaml ] minimum requirement, only pydantic included user@pc:~$ pip install argdantic","title":"Installation"},{"location":"#a-simple-example","text":"Creating a CLI with argdantic can be as simple as: from argdantic import ArgParser # 1. create a CLI instance parser = ArgParser () # 2. decorate the function to be called @parser . command () def buy ( name : str , quantity : int , price : float ): print ( f \"Bought { quantity } { name } at $ { price : .2f } .\" ) # 3. Use your CLI by simply calling it if __name__ == \"__main__\" : parser () Then, in a terminal, the help command can provide the usual information: $ python cli.py --help > usage: buy [-h] --name TEXT --quantity INT --price FLOAT > > optional arguments: > -h, --help show this help message and exit > --name TEXT > --quantity INT > --price FLOAT This gives us the required arguments for the execution: $ python cli.py --name apples --quantity 10 --price 3 .4 > Bought 10 apples at $3.40.","title":"A Simple Example"},{"location":"#acknowledgements","text":"This project is heavily inspired by other awesome works, including: click : the most popular CLI library for Python for complex applications, the best alternative to argparse . typer : based on click , a great project that inspired the creation of argdantic . It is a great alternative, however it does not support pydantic models at the moment. pydantic-cli : a mature project that provides a similar experience to argdantic , however it does not support nested models, commands and different sources. Do you like argdantic , but prefer click as a CLI library? Check out clidantic , a twin project that uses click instead of argparse .","title":"Acknowledgements"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"guide/composition/","text":"Composition Exploiting both pydantic and argparse functionality, argdantic allows two types of composition: nested models and nested parsers . The first allows to define complex inputs, building a hierarchy of models and submodels. The second allows to organize your code into a series of commands and subcommands, each with its own set of arguments. Nested Models Strictly speaking, every argument stated in the signature of a @command function is wrapped into a pydantic model. This allows two things: first, it makes it easier and more natural for the user to define input arguments, and second, it allows to define complex inputs, building a hierarchy of models and submodels, directly exploiting the powerful features of pydantic . For example, let's say we want to define a command that takes an input Item , which in turn contains an Image model. We can do this by defining two models, and then using the Item model as an argument of the @command function: nested_models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import Set from pydantic import BaseModel from argdantic import ArgParser class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tags : Set [ str ] = set () image : Image = None cli = ArgParser () @cli . command () def create_item ( item : Item ): print ( item ) if __name__ == \"__main__\" : cli () Underneath, argdantic will automatically create the following structure: A nameless root model, inheriting from BaseConfig if any extra feature is required, containing: A field item , of type Item , which defines: A field name , of type str , A field description , of type str , A field price , of type float , A field tags , of type Set[str] , A field image , of type Image , which defines: A field url , of type str , A field name , of type str The resulting command line interface, with the help message, will be the following: $ python nested_models.py --help > usage: nested_models.py [-h] --item.name TEXT --item.description TEXT --item.price FLOAT --item.tags TEXT [TEXT ...] --item.image.url TEXT --item.image.name TEXT > > optional arguments: > -h, --help show this help message and exit > --item.name TEXT (required) > --item.description TEXT > --item.price FLOAT (required) > --item.tags [TEXT [TEXT ...]] (default: set()) > --item.image.url TEXT (required) > --item.image.name TEXT (required) Executing the command with the required arguments will result in the following output: $ python nested_models.py --item.name \"My Item\" \\ --item.description \"My Item Description\" \\ --item.price 10 .0 \\ --item.tags \"tag1\" \"tag2\" \\ --item.image.url \"https://example.com/image.png\" \\ --item.image.name \"My Image\" > name='My Item' description='My Item Description' price=10.0 tags={'tag1', 'tag2'} image=Image(url='https://example.com/image.png' name='My Image') Note Despite that the Image model defaults to None , you will notice that its fields are still required. Strictly speaking, that's the correct behavior, since these fields are not optional. This would have also happened if the image field had an explicit Image() default value. This is a very simple example, but it shows how to define complex inputs, and how to exploit the power of pydantic to define a hierarchy of models. In fact, you can define as many levels of nesting as you want, building a complex configuration that can be easily validated and parsed. Nested configurations are also supported using different input sources, such as environment variables and configuration files: see the Input Sources section for more details. Nested Parsers argdantic also allows to organize your code into a series of commands and subcommands, each with its own set of arguments. A single parser is enough to define a list of commands at the same level. However, sometimes it is necessary to define a hierarchy of commands, such as git commit and git push . This can be done by defining multiple parsers, each with its own set of commands, and then merging them together, like so: nested_parsers.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from argdantic import ArgParser users = ArgParser ( name = \"users\" ) books = ArgParser ( name = \"books\" ) @users . command () def add_user ( name : str , age : int ): \"\"\"Adds a single user.\"\"\" print ( f \"Adding user: { name } ( { age } )\" ) @users . command () def delete_user ( name : str ): \"\"\"Deletes a user by name.\"\"\" print ( f \"Deleting user: { name } \" ) @books . command () def add_book ( name : str , author : str ): \"\"\"Adds a book, with name and author.\"\"\" print ( f \"Adding book: { name } ( { author } )\" ) @books . command () def delete_book ( name : str ): \"\"\"Deletes a book by name.\"\"\" print ( f \"Deleting book: { name } \" ) cli = ArgParser () cli . add_parser ( users ) cli . add_parser ( books ) if __name__ == \"__main__\" : cli () There are a few things to notice here: The subparsers must have a name, which is used to identify them when calling the CLI. This can be provided by either providing a name during instantiation, or by passing a name keyword argument to the add_parser method. In general, the main parser does not require a name, unless it is used as a subparser of another parser. When executing the help command, the following output will be produced: $ python nested_parsers.py --help > usage: nested_parsers.py [-h] <command> ... > > positional arguments: > <command> > users > books > > optional arguments: > -h, --help show this help message and exit Note The description provided by the help command is quite limited at the moment: as you can see, the name of the subparsers is shown, but not their description. This is a known limitation, and it will be addressed in the future. The same can be done on the subgroup, calling the help command on the users subparser: $ python nested_parsers.py users --help > usage: nested_parsers.py users [-h] <command> ... > > positional arguments: > <command> > add-user Adds a single user. > delete-user > Deletes a user by name. > > optional arguments: > -h, --help show this help message and exit Finally, the help command can be called on the subcommand, showing the description and the arguments: $ python nested_parsers.py users add-user --help > usage: nested_parsers.py users add-user [-h] --name TEXT --age INT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) > --age INT (required) Last but not least, the command can be executed, by passing the required arguments: $ python nested_parsers.py users add-user --name \"John Doe\" --age 30 > Adding user: John Doe (30) Of course, nested models and nested parsers can be combined together, to create a complex hierarchy of commands and arguments. Fantasy is the limit, well, at least until you run out of RAM.","title":"Composition"},{"location":"guide/composition/#composition","text":"Exploiting both pydantic and argparse functionality, argdantic allows two types of composition: nested models and nested parsers . The first allows to define complex inputs, building a hierarchy of models and submodels. The second allows to organize your code into a series of commands and subcommands, each with its own set of arguments.","title":"Composition"},{"location":"guide/composition/#nested-models","text":"Strictly speaking, every argument stated in the signature of a @command function is wrapped into a pydantic model. This allows two things: first, it makes it easier and more natural for the user to define input arguments, and second, it allows to define complex inputs, building a hierarchy of models and submodels, directly exploiting the powerful features of pydantic . For example, let's say we want to define a command that takes an input Item , which in turn contains an Image model. We can do this by defining two models, and then using the Item model as an argument of the @command function: nested_models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import Set from pydantic import BaseModel from argdantic import ArgParser class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tags : Set [ str ] = set () image : Image = None cli = ArgParser () @cli . command () def create_item ( item : Item ): print ( item ) if __name__ == \"__main__\" : cli () Underneath, argdantic will automatically create the following structure: A nameless root model, inheriting from BaseConfig if any extra feature is required, containing: A field item , of type Item , which defines: A field name , of type str , A field description , of type str , A field price , of type float , A field tags , of type Set[str] , A field image , of type Image , which defines: A field url , of type str , A field name , of type str The resulting command line interface, with the help message, will be the following: $ python nested_models.py --help > usage: nested_models.py [-h] --item.name TEXT --item.description TEXT --item.price FLOAT --item.tags TEXT [TEXT ...] --item.image.url TEXT --item.image.name TEXT > > optional arguments: > -h, --help show this help message and exit > --item.name TEXT (required) > --item.description TEXT > --item.price FLOAT (required) > --item.tags [TEXT [TEXT ...]] (default: set()) > --item.image.url TEXT (required) > --item.image.name TEXT (required) Executing the command with the required arguments will result in the following output: $ python nested_models.py --item.name \"My Item\" \\ --item.description \"My Item Description\" \\ --item.price 10 .0 \\ --item.tags \"tag1\" \"tag2\" \\ --item.image.url \"https://example.com/image.png\" \\ --item.image.name \"My Image\" > name='My Item' description='My Item Description' price=10.0 tags={'tag1', 'tag2'} image=Image(url='https://example.com/image.png' name='My Image') Note Despite that the Image model defaults to None , you will notice that its fields are still required. Strictly speaking, that's the correct behavior, since these fields are not optional. This would have also happened if the image field had an explicit Image() default value. This is a very simple example, but it shows how to define complex inputs, and how to exploit the power of pydantic to define a hierarchy of models. In fact, you can define as many levels of nesting as you want, building a complex configuration that can be easily validated and parsed. Nested configurations are also supported using different input sources, such as environment variables and configuration files: see the Input Sources section for more details.","title":"Nested Models"},{"location":"guide/composition/#nested-parsers","text":"argdantic also allows to organize your code into a series of commands and subcommands, each with its own set of arguments. A single parser is enough to define a list of commands at the same level. However, sometimes it is necessary to define a hierarchy of commands, such as git commit and git push . This can be done by defining multiple parsers, each with its own set of commands, and then merging them together, like so: nested_parsers.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from argdantic import ArgParser users = ArgParser ( name = \"users\" ) books = ArgParser ( name = \"books\" ) @users . command () def add_user ( name : str , age : int ): \"\"\"Adds a single user.\"\"\" print ( f \"Adding user: { name } ( { age } )\" ) @users . command () def delete_user ( name : str ): \"\"\"Deletes a user by name.\"\"\" print ( f \"Deleting user: { name } \" ) @books . command () def add_book ( name : str , author : str ): \"\"\"Adds a book, with name and author.\"\"\" print ( f \"Adding book: { name } ( { author } )\" ) @books . command () def delete_book ( name : str ): \"\"\"Deletes a book by name.\"\"\" print ( f \"Deleting book: { name } \" ) cli = ArgParser () cli . add_parser ( users ) cli . add_parser ( books ) if __name__ == \"__main__\" : cli () There are a few things to notice here: The subparsers must have a name, which is used to identify them when calling the CLI. This can be provided by either providing a name during instantiation, or by passing a name keyword argument to the add_parser method. In general, the main parser does not require a name, unless it is used as a subparser of another parser. When executing the help command, the following output will be produced: $ python nested_parsers.py --help > usage: nested_parsers.py [-h] <command> ... > > positional arguments: > <command> > users > books > > optional arguments: > -h, --help show this help message and exit Note The description provided by the help command is quite limited at the moment: as you can see, the name of the subparsers is shown, but not their description. This is a known limitation, and it will be addressed in the future. The same can be done on the subgroup, calling the help command on the users subparser: $ python nested_parsers.py users --help > usage: nested_parsers.py users [-h] <command> ... > > positional arguments: > <command> > add-user Adds a single user. > delete-user > Deletes a user by name. > > optional arguments: > -h, --help show this help message and exit Finally, the help command can be called on the subcommand, showing the description and the arguments: $ python nested_parsers.py users add-user --help > usage: nested_parsers.py users add-user [-h] --name TEXT --age INT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) > --age INT (required) Last but not least, the command can be executed, by passing the required arguments: $ python nested_parsers.py users add-user --name \"John Doe\" --age 30 > Adding user: John Doe (30) Of course, nested models and nested parsers can be combined together, to create a complex hierarchy of commands and arguments. Fantasy is the limit, well, at least until you run out of RAM.","title":"Nested Parsers"},{"location":"guide/customization/","text":"Customization Argdantic supports a number of customization options, which can be used to change the default behavior of the CLI. Being based on argparse and pydantic , the customization options are limitless, however the most common ones are listed below. Command names: a custom help message to be displayed when the --help flag is passed. Command description: a custom help message to be displayed when the --help flag is passed. Field descriptions: a custom help message to be displayed when the --help flag is passed. Field aliases: a list of optional names that can be used instead of the field name. Field default values: a default value to be used when the field is not provided. The following sections will provide a brief overview of these options, and how to use them. Command Names By default, the name of the function that is decorated with @parser.command() is used as the name of the command. This can be changed by passing a name argument to the decorator: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command ( name = \"greetings\" ) def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) Wait a minute, where is the custom name? By default, with only one command, the name of the command is not displayed, nor used to execute the command. This can be changed by: Registering more than one command, the easiest option. By passing the force_group argument to the parser. Multiple Commands When more than one command is registered, its name is required to execute that specific CLI function. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from argdantic import ArgParser cli = ArgParser () @cli . command ( name = \"hi\" ) def hello ( name : str ): \"\"\" Say hello. \"\"\" print ( f \"Hello, { name } !\" ) @cli . command ( name = \"bye\" ) def goodbye ( name : str ): \"\"\" Say goodbye. \"\"\" print ( f \"Goodbye, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > hi Say hello. > bye Say goodbye. > > optional arguments: > -h, --help show this help message and exit The hi and bye commands are now available, and can be executed by passing their name as the first argument: $ python main.py hi --name John > Hello, John! You also probably noticed that the commands also provide a description. This can be customized in many ways, and will be covered in the next section. Forced Groups The force_group argument can be used to force the creation of a group, even if only one command is registered. This can be useful if you want to force users to provide the command name upon execution. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command ( name = \"greetings\" ) def hello ( name : str ): \"\"\" Say hello. \"\"\" print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > greetings > Say hello. > > optional arguments: > -h, --help show this help message and exit The greetings command is now available, and can be executed by passing its name as the first argument: $ python main.py greetings --name John > Hello, John! Command Descriptions You may have noticed from the previous example that the commands also provide a description. Descriptions can be customized in two simple ways: Automatically, by simply providing a docstring to the function. Manually passing a help argument to the @parser.command() decorator. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command ( help = \"Print a greeting message\" ) def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () Is equivalent to: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command () def hello ( name : str ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the scripts will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > hello Print a greeting message. > > optional arguments: > -h, --help show this help message and exit Default Values Of course, any good CLI tool should provide the user with a way to provide default values for the fields. Given that defining a command is as simple as defining a function, introducing default values can also be as simple as providing a default value to the function arguments. For instance: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str = \"World\" , age : int = 42 ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () This can be executed with no arguments without any issues: $ python main.py > Hello, World! > You are 42 years old. The default values are also provided in the help message, so that the user is informed about them: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT (default: World) > --age INT (default: 42) Default Values and Required Fields Of course, if a field provides a default value, it is no longer required. This implies that every field must be assigned in some way, either by providing it beforehand or during execution, which will respectively add a default or required flag to the help message. But, as a famous grand master once said, there is another : when the default is None , the field is neither marked as default nor required , so the help message will not contain any flag. At the time of writing, this is the only way to provide a true optional field. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str = None , age : int = None ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () The help message will now look like this: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT > --age INT These are very simple examples, but they can be extended to any field, including more complex ones such as List , Dict , and so on. There are also a few other ways to provide default values, which will be covered in the next sections. Field Options A CLI cannot be complete without a way to customize the fields. argdantic provides a way to customize the fields through the ArgField function, which can be seen as a light wrapper around pydantic 's Field with a few changes to make it more suitable for CLI tools. ArgField , on top of the arguments provided by Field , provides the following options: names : A variable list of names to provide aliases for the field. This substitutes the positional default value in pydantic . default : A keyword argument to provide a default value for the field. This is now a keyword argument, mirroring argparse . description : A keyword argument to provide a description for the field. This uses the same functionality of Field 's description . Aliases A common functionality provided by argparse is the ability to provide aliases for the fields. This option is made available in argdantic by using the ArgField modifier to the field. Optional field names can be provided in the following way: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" ), age : int = ArgField ( \"-a\" )): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () Executing the script with the --help flag will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT --age INT > > optional arguments: > -h, --help show this help message and exit > --name TEXT, -n TEXT (required) > --age INT, -a INT (required) The message now shows to the user that the --name and --n flags are equivalent, as well as the --age and --a flags. Let's try to execute the script with the new flags: $ python main.py -n John -a 42 > Hello, John! > You are 42 years old. Default with Fields Substituting the default value in the function signature with the ArgField modifier does not preclude the use of the default value in the function signature. This is now possible by using the default keyword argument: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" , default = \"John\" ), age : int = ArgField ( \"-a\" , default = 30 ), ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () As before, the script can be executed without any arguments: $ python main.py > Hello, World! > You are 42 years old. Descriptions Last but not least, CLI arguments are usually accompanied by a description. This can be provided in the same way as the default value, by using the description keyword argument: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" , default = \"John\" , description = \"your name\" ), age : int = ArgField ( \"-a\" , default = 30 , description = \"your age\" ), ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () This description will be displayed in the help message: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT, -n TEXT your name (default: John) > --age INT, -a INT your age (default: 30) Other Options There are a few other options that can be provided to the ArgField modifier, which are not covered in this tutorial, but can be found in the pydantic documentation. These include, just to name a few, validators, constraints, and so on. In general, every other argument provided to Field can be provided to ArgField in the same way.","title":"Customization"},{"location":"guide/customization/#customization","text":"Argdantic supports a number of customization options, which can be used to change the default behavior of the CLI. Being based on argparse and pydantic , the customization options are limitless, however the most common ones are listed below. Command names: a custom help message to be displayed when the --help flag is passed. Command description: a custom help message to be displayed when the --help flag is passed. Field descriptions: a custom help message to be displayed when the --help flag is passed. Field aliases: a list of optional names that can be used instead of the field name. Field default values: a default value to be used when the field is not provided. The following sections will provide a brief overview of these options, and how to use them.","title":"Customization"},{"location":"guide/customization/#command-names","text":"By default, the name of the function that is decorated with @parser.command() is used as the name of the command. This can be changed by passing a name argument to the decorator: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command ( name = \"greetings\" ) def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) Wait a minute, where is the custom name? By default, with only one command, the name of the command is not displayed, nor used to execute the command. This can be changed by: Registering more than one command, the easiest option. By passing the force_group argument to the parser.","title":"Command Names"},{"location":"guide/customization/#multiple-commands","text":"When more than one command is registered, its name is required to execute that specific CLI function. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from argdantic import ArgParser cli = ArgParser () @cli . command ( name = \"hi\" ) def hello ( name : str ): \"\"\" Say hello. \"\"\" print ( f \"Hello, { name } !\" ) @cli . command ( name = \"bye\" ) def goodbye ( name : str ): \"\"\" Say goodbye. \"\"\" print ( f \"Goodbye, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > hi Say hello. > bye Say goodbye. > > optional arguments: > -h, --help show this help message and exit The hi and bye commands are now available, and can be executed by passing their name as the first argument: $ python main.py hi --name John > Hello, John! You also probably noticed that the commands also provide a description. This can be customized in many ways, and will be covered in the next section.","title":"Multiple Commands"},{"location":"guide/customization/#forced-groups","text":"The force_group argument can be used to force the creation of a group, even if only one command is registered. This can be useful if you want to force users to provide the command name upon execution. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command ( name = \"greetings\" ) def hello ( name : str ): \"\"\" Say hello. \"\"\" print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > greetings > Say hello. > > optional arguments: > -h, --help show this help message and exit The greetings command is now available, and can be executed by passing its name as the first argument: $ python main.py greetings --name John > Hello, John!","title":"Forced Groups"},{"location":"guide/customization/#command-descriptions","text":"You may have noticed from the previous example that the commands also provide a description. Descriptions can be customized in two simple ways: Automatically, by simply providing a docstring to the function. Manually passing a help argument to the @parser.command() decorator. For instance, the following script: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command ( help = \"Print a greeting message\" ) def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () Is equivalent to: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from argdantic import ArgParser cli = ArgParser ( force_group = True ) @cli . command () def hello ( name : str ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () When executed, the scripts will provide the following output: $ python main.py --help > usage: main.py [-h] <command> ... > > positional arguments: > <command> > hello Print a greeting message. > > optional arguments: > -h, --help show this help message and exit","title":"Command Descriptions"},{"location":"guide/customization/#default-values","text":"Of course, any good CLI tool should provide the user with a way to provide default values for the fields. Given that defining a command is as simple as defining a function, introducing default values can also be as simple as providing a default value to the function arguments. For instance: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str = \"World\" , age : int = 42 ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () This can be executed with no arguments without any issues: $ python main.py > Hello, World! > You are 42 years old. The default values are also provided in the help message, so that the user is informed about them: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT (default: World) > --age INT (default: 42)","title":"Default Values"},{"location":"guide/customization/#default-values-and-required-fields","text":"Of course, if a field provides a default value, it is no longer required. This implies that every field must be assigned in some way, either by providing it beforehand or during execution, which will respectively add a default or required flag to the help message. But, as a famous grand master once said, there is another : when the default is None , the field is neither marked as default nor required , so the help message will not contain any flag. At the time of writing, this is the only way to provide a true optional field. main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str = None , age : int = None ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () The help message will now look like this: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT > --age INT These are very simple examples, but they can be extended to any field, including more complex ones such as List , Dict , and so on. There are also a few other ways to provide default values, which will be covered in the next sections.","title":"Default Values and Required Fields"},{"location":"guide/customization/#field-options","text":"A CLI cannot be complete without a way to customize the fields. argdantic provides a way to customize the fields through the ArgField function, which can be seen as a light wrapper around pydantic 's Field with a few changes to make it more suitable for CLI tools. ArgField , on top of the arguments provided by Field , provides the following options: names : A variable list of names to provide aliases for the field. This substitutes the positional default value in pydantic . default : A keyword argument to provide a default value for the field. This is now a keyword argument, mirroring argparse . description : A keyword argument to provide a description for the field. This uses the same functionality of Field 's description .","title":"Field Options"},{"location":"guide/customization/#aliases","text":"A common functionality provided by argparse is the ability to provide aliases for the fields. This option is made available in argdantic by using the ArgField modifier to the field. Optional field names can be provided in the following way: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" ), age : int = ArgField ( \"-a\" )): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () Executing the script with the --help flag will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT --age INT > > optional arguments: > -h, --help show this help message and exit > --name TEXT, -n TEXT (required) > --age INT, -a INT (required) The message now shows to the user that the --name and --n flags are equivalent, as well as the --age and --a flags. Let's try to execute the script with the new flags: $ python main.py -n John -a 42 > Hello, John! > You are 42 years old.","title":"Aliases"},{"location":"guide/customization/#default-with-fields","text":"Substituting the default value in the function signature with the ArgField modifier does not preclude the use of the default value in the function signature. This is now possible by using the default keyword argument: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" , default = \"John\" ), age : int = ArgField ( \"-a\" , default = 30 ), ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () As before, the script can be executed without any arguments: $ python main.py > Hello, World! > You are 42 years old.","title":"Default with Fields"},{"location":"guide/customization/#descriptions","text":"Last but not least, CLI arguments are usually accompanied by a description. This can be provided in the same way as the default value, by using the description keyword argument: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from argdantic import ArgField , ArgParser cli = ArgParser () @cli . command () def hello ( name : str = ArgField ( \"-n\" , default = \"John\" , description = \"your name\" ), age : int = ArgField ( \"-a\" , default = 30 , description = \"your age\" ), ): \"\"\"Print a greeting message.\"\"\" print ( f \"Hello, { name } !\" ) print ( f \"You are { age } years old.\" ) if __name__ == \"__main__\" : cli () This description will be displayed in the help message: $ python main.py --help > usage: main.py [-h] [--name TEXT] [--age INT] > > optional arguments: > -h, --help show this help message and exit > --name TEXT, -n TEXT your name (default: John) > --age INT, -a INT your age (default: 30)","title":"Descriptions"},{"location":"guide/customization/#other-options","text":"There are a few other options that can be provided to the ArgField modifier, which are not covered in this tutorial, but can be found in the pydantic documentation. These include, just to name a few, validators, constraints, and so on. In general, every other argument provided to Field can be provided to ArgField in the same way.","title":"Other Options"},{"location":"guide/intro/","text":"Introduction Parsers The main building block of argdantic is represented by a ArgParser instance. Every CLI requires at least one active parser, which serves as main entry point. A parser simply acts as a collection of commands, which are only executed upon call. Any parser must first be imported, instantiated, then called in a main, like so: main.py 1 2 3 4 5 6 7 from argdantic import ArgParser cli = ArgParser () if __name__ == \"__main__\" : cli () However, this code is not enough to have a working CLI . If you attempt to run it you will obtain: $ python main.py > AssertionError: Parser must have at least one command or group of commands This is the expected behavior, as a parser without any command is useless: check the Commands section for more information. Commands Commands are the backbone of any parser. Underneath, they are simply functions that are called when requested by the user. A command can be added to a parser by using the @parser.command() decorator, like so: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello_world (): print ( \"Hello World!\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py > Hello World! This is a step forward, however the command is still not very useful. Let's see how to add arguments to it. Arguments Arguments are the way to provide information and dynamic functionality to a command. They are defined by simply adding them to the command's signature, like so: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () Note Of course, typing is crucial to ensure that argdantic can correctly parse the arguments. The framework however will be kind enough to provide an error message if a field does not provide a type annotation. When executed, the script will provide the following output: $ python main.py > usage: main.py [-h] --name TEXT > main.py: error: the following arguments are required: --name This is correct, as the --name argument is required. Let's see how to provide it. $ python main.py --name John > Hello, John! Help Messages Of course, randomly executing a command without any information is not very useful. The --help argument is automatically added to every command, and provides a summary of the command's arguments. For instance, running the help command on the previous example will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) You may have noticed two things: if you are familiar with argparse , you probably already know that the --help argument is automatically added to every command. In addition, argdantic explicitly provides the (required) tag to every argument that does not specify a default value. This is done to ensure that the user is aware of some missing options, even before the command is executed.","title":"Introduction"},{"location":"guide/intro/#introduction","text":"","title":"Introduction"},{"location":"guide/intro/#parsers","text":"The main building block of argdantic is represented by a ArgParser instance. Every CLI requires at least one active parser, which serves as main entry point. A parser simply acts as a collection of commands, which are only executed upon call. Any parser must first be imported, instantiated, then called in a main, like so: main.py 1 2 3 4 5 6 7 from argdantic import ArgParser cli = ArgParser () if __name__ == \"__main__\" : cli () However, this code is not enough to have a working CLI . If you attempt to run it you will obtain: $ python main.py > AssertionError: Parser must have at least one command or group of commands This is the expected behavior, as a parser without any command is useless: check the Commands section for more information.","title":"Parsers"},{"location":"guide/intro/#commands","text":"Commands are the backbone of any parser. Underneath, they are simply functions that are called when requested by the user. A command can be added to a parser by using the @parser.command() decorator, like so: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello_world (): print ( \"Hello World!\" ) if __name__ == \"__main__\" : cli () When executed, the script will provide the following output: $ python main.py > Hello World! This is a step forward, however the command is still not very useful. Let's see how to add arguments to it.","title":"Commands"},{"location":"guide/intro/#arguments","text":"Arguments are the way to provide information and dynamic functionality to a command. They are defined by simply adding them to the command's signature, like so: main.py 1 2 3 4 5 6 7 8 9 10 11 12 from argdantic import ArgParser cli = ArgParser () @cli . command () def hello ( name : str ): print ( f \"Hello, { name } !\" ) if __name__ == \"__main__\" : cli () Note Of course, typing is crucial to ensure that argdantic can correctly parse the arguments. The framework however will be kind enough to provide an error message if a field does not provide a type annotation. When executed, the script will provide the following output: $ python main.py > usage: main.py [-h] --name TEXT > main.py: error: the following arguments are required: --name This is correct, as the --name argument is required. Let's see how to provide it. $ python main.py --name John > Hello, John!","title":"Arguments"},{"location":"guide/intro/#help-messages","text":"Of course, randomly executing a command without any information is not very useful. The --help argument is automatically added to every command, and provides a summary of the command's arguments. For instance, running the help command on the previous example will provide the following output: $ python main.py --help > usage: main.py [-h] --name TEXT > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) You may have noticed two things: if you are familiar with argparse , you probably already know that the --help argument is automatically added to every command. In addition, argdantic explicitly provides the (required) tag to every argument that does not specify a default value. This is done to ensure that the user is aware of some missing options, even before the command is executed.","title":"Help Messages"},{"location":"guide/sources/","text":"Input Sources argdantic allows you to define the arguments of your CLI in a variety of ways, including: Command line arguments, using argparse Environment variables or .env files, using python-dotenv Configuration files, using JSON , YAML , or TOML files. Each of these input sources can be used independently, or in combination with each other. The priority of the input sources is given by the order in which they are defined, with the last one having the highest priority. Of course, the command line arguments always have the highest priority, and they can be used to override any other input source. Since every command is virtually independent, sources are part of the command definition . This means that you can define different sources for different commands in the same CLI. For instance, the following example defines a single command with many different sources: sources.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from typing import Set from pydantic import BaseModel from argdantic import ArgParser from argdantic.sources import ( EnvSettingsSource , JsonSettingsSource , TomlSettingsSource , YamlSettingsSource , ) class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tags : Set [ str ] = set () image : Image = None cli = ArgParser () @cli . command ( sources = [ EnvSettingsSource ( env_file = \".env\" ), JsonSettingsSource ( json_file = \"settings.json\" ), YamlSettingsSource ( yaml_file = \"settings.yaml\" ), TomlSettingsSource ( toml_file = \"settings.toml\" ), ] ) def create_item ( item : Item ): print ( item ) if __name__ == \"__main__\" : cli () Warning Documentation under construction, be patient!","title":"Input Sources"},{"location":"guide/sources/#input-sources","text":"argdantic allows you to define the arguments of your CLI in a variety of ways, including: Command line arguments, using argparse Environment variables or .env files, using python-dotenv Configuration files, using JSON , YAML , or TOML files. Each of these input sources can be used independently, or in combination with each other. The priority of the input sources is given by the order in which they are defined, with the last one having the highest priority. Of course, the command line arguments always have the highest priority, and they can be used to override any other input source. Since every command is virtually independent, sources are part of the command definition . This means that you can define different sources for different commands in the same CLI. For instance, the following example defines a single command with many different sources: sources.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from typing import Set from pydantic import BaseModel from argdantic import ArgParser from argdantic.sources import ( EnvSettingsSource , JsonSettingsSource , TomlSettingsSource , YamlSettingsSource , ) class Image ( BaseModel ): url : str name : str class Item ( BaseModel ): name : str description : str = None price : float tags : Set [ str ] = set () image : Image = None cli = ArgParser () @cli . command ( sources = [ EnvSettingsSource ( env_file = \".env\" ), JsonSettingsSource ( json_file = \"settings.json\" ), YamlSettingsSource ( yaml_file = \"settings.yaml\" ), TomlSettingsSource ( toml_file = \"settings.toml\" ), ] ) def create_item ( item : Item ): print ( item ) if __name__ == \"__main__\" : cli () Warning Documentation under construction, be patient!","title":"Input Sources"},{"location":"guide/types/","text":"Field Types Thanks to features provided by pydantic 's data definitions, argdantic supports a large amount of field types, starting from the standard library up to JSON inputs. Primitive types Considering primitive, non-complex data types, the library supports the following: str : values accepted as is, parsed as simple text without further processing. int : tries to convert any given input into an integer through int(value) . float : similarly, tries to convert any given input into a floating point number through float(value) . bytes : similar to strings, however in this case the underlying representation remains in bytes. bool : by default, booleans are intended as flag options. In this case any boolean field will have two corresponding CLI flags --field/--no-field . The following example shows a brief overview of the primitive types: primitives.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from argdantic import ArgParser cli = ArgParser () @cli . command () def status ( name : str , age : int , weight : float , data : bytes , flag : bool ): print ( f \"name: { name } \" ) print ( f \"age: { age } \" ) print ( f \"weight: { weight } \" ) print ( f \"data: { data } \" ) print ( f \"flag: { flag } \" ) if __name__ == \"__main__\" : cli () With the following help message: $ python primitives.py --help > usage: primitives.py [-h] --name TEXT --age INT --weight FLOAT --data BYTES (--flag | --no-flag) > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) > --age INT (required) > --weight FLOAT (required) > --data BYTES (required) > --flag > --no-flag Note Observe that the --flag and --no-flag options are not marked as required. That is the expected behaviour: strictly speaking, taken individually , they are not required. However, being mutually exclusive, one of either --flag or --no-flag is still needed. `argdantic`` takes care of converting the provided fields into argparse arguments, so that the automatically generated description reamins as faithful as possible. Bear in mind that types are exploited only for documentation purposes, the final type checking will be carried out by pydantic . Most complex types are often interpreted as strings, unless specified otherwise. Complex types Thanks to the powerful data definitions provided by pydantic , argdantic supports a large amount of complex types, Currently, the following types have been tested and supported: Standard Library types Generally speaking, non-typed complex types will default to strings unless specified otherwise. list : without specifying the internal type, list fields will behave as multiple options of string items. Internally, argdantic exploits _argparse's nargs option to handle sequences. In this case, the argument can be repeated multiple times to build a list. For instance, python cli.py --add 1 2 will result in a list [1, 2] . tuple : similar to lists, this will behave as an unbounded sequence of strings, with multiple parameters. dict : dictionaries are interpreted as JSON strings. In this case, there will be no further validation. Given that valid JSON strings require double quotes, arguments provided through the command line must use single-quoted strings. For instance, python cli.py --extras '{\"items\": 12}' will be successfully parsed, while python cli.py --extras \"{'items': 12}\" will not. set : again, from a command line point of view, sets are a simple list of values. In this case, repeated values will be excluded. For instance, python cli.py --add a --add b --add a will result in a set {'a', 'b'} . frozenset : frozen sets adopt the same behavior as normal sets, with the only difference that they remain immutable. deque : similarly, deques act as sequences from a CLI standpoint, while being treaded as double-ended queues in code. range : ranges are interpreted as a sequence of integers, with the same behavior as lists and tuples. Typing Containers Any : For obvious reasons, Any fields will behave as str options without further processing. Optional : optional typing can be interpreted as syntactic sugar , meaning it will not have any effect on the underlying validation, but it provides an explicit declaration that the field can also accept None as value. List : Similar to standard lists, typing Lists behave as sequences of items. In this case however the inner type is exploited to provide further validation through pydantic . For instance, python cli.py --add a --add b will result in a validation error for a list of integers List[int] . Tuple : typing Tuples can behave in two ways: when using a variable length structure (i.e., Tuple[int] or Tuple[int, ...] ), tuples act as a sequence of typed items, validated through pydantic, where the parameter is specified multiple times. When using a _fixed length structure (i.e., Tuple[int, int] or similar), they are considered as fixed nargs options, where the parameter is specified once, followed by the sequence of values separated by whitespaces. For instance . python cli.py --items a b c will results in a tuple ('a', 'b', 'c') . If the items tuple specified only two items, the command will result in a validation error. Dict : Similar to the standard dict field, typing dictionaries require a JSON string as input. However, inner types allow for a finer validation: for instance, considering a metrics: Dict[str, float] field, --metrics '{\"f1\": 0.93}' is accepted, while --metrics '{\"auc\": \"a\"}' is not a valid input. Deque : with the same reasoning of typed lists and tuples, Deques will act as sequences with a specific type. Set : As you guessed, typed sets act as multiple options where repeated items are excluded, with additional type validation on the items themselves. FrozenSet : as with Sets , but they represent immutable structures after parsing. Sequence and Iterables : with no surpise, sequences and iterables act as sequences, nothing much to add here. Warning for obvious reasons, Union typings are not supported at this time. Parsing a multi-valued parameter is really more of a phylosophical problem than a technical one. Future releases will consider the support for this typing. The code below provides a relatively comprehensive view of most container types supported through argdantic . containers.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Deque , Dict , FrozenSet , List , Optional , Sequence , Set , Tuple from argdantic import ArgParser cli = ArgParser () @cli . command () def run ( simple_list : list , list_of_ints : List [ int ], simple_tuple : tuple , multi_typed_tuple : Tuple [ int , float , str , bool ], simple_dict : dict , dict_str_float : Dict [ str , float ], simple_set : set , set_bytes : Set [ bytes ], frozen_set : FrozenSet [ int ], none_or_str : Optional [ str ], sequence_of_ints : Sequence [ int ], compound : Dict [ str , List [ Set [ int ]]], deque : Deque [ int ], ): print ( f \"simple_list: { simple_list } \" ) print ( f \"list_of_ints: { list_of_ints } \" ) print ( f \"simple_tuple: { simple_tuple } \" ) print ( f \"multi_typed_tuple: { multi_typed_tuple } \" ) print ( f \"simple_dict: { simple_dict } \" ) print ( f \"dict_str_float: { dict_str_float } \" ) print ( f \"simple_set: { simple_set } \" ) print ( f \"set_bytes: { set_bytes } \" ) print ( f \"frozen_set: { frozen_set } \" ) print ( f \"none_or_str: { none_or_str } \" ) print ( f \"sequence_of_ints: { sequence_of_ints } \" ) print ( f \"compound: { compound } \" ) print ( f \"deque: { deque } \" ) if __name__ == \"__main__\" : cli () Executing this script with the help command will provide the description for the current configuration. Also, defaults are allowed and validated. $ python containers.py --help > usage: containers.py [-h] --simple-list TEXT [TEXT ...] --list-of-ints INT [INT ...] > --simple-tuple TEXT [TEXT ...] --multi-typed-tuple INT FLOAT TEXT BOOL --simple-dict JSON > --dict-str-float JSON --simple-set TEXT [TEXT ...] --set-bytes BYTES [BYTES ...] > --frozen-set INT [INT ...] --none-or-str TEXT --sequence-of-ints INT [INT ...] > --compound JSON --deque INT [INT ...] > > optional arguments: > -h, --help show this help message and exit > --simple-list TEXT [TEXT ...] (required) > --list-of-ints INT [INT ...] (required) > --simple-tuple TEXT [TEXT ...] (required) > --multi-typed-tuple INT FLOAT TEXT BOOL (required) > --simple-dict JSON (required) > --dict-str-float JSON (required) > --simple-set TEXT [TEXT ...] (required) > --set-bytes BYTES [BYTES ...] (required) > --frozen-set INT [INT ...] (required) > --none-or-str TEXT (required) > --sequence-of-ints INT [INT ...] (required) > --compound JSON (required) > --deque INT [INT ...] (required) Literals and Enums Sometimes it may be useful to directly limit the choices of certain fields, by letting the user select among a fixed list of values. In this case, argdantic provides this feature using pydantic 's support for Enum and Literal types, parsed from the command line through the choice argument option. While Enums represent the standard way to provide choice-based options, Literals can be seen as a lightweight enumeration. In general, the latter are simpler and easier to handle than the former for most use cases. Enums on the other hand provide both a name and a value component, where only the former is exploited for the parameter definition. The latter can represent any kind of object, therefore making enums more suitable for more complex use cases. The following script presents a sample of possible choice definitions in clidantic : choices.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from enum import Enum , IntEnum from typing import Literal from argdantic import ArgParser cli = ArgParser () class ToolEnum ( Enum ): hammer = \"Hammer\" screwdriver = \"Screwdriver\" class HTTPEnum ( IntEnum ): ok = 200 not_found = 404 internal_error = 500 @cli . command () def run ( a : Literal [ \"one\" , \"two\" ] = \"two\" , b : Literal [ 1 , 2 ] = 2 , c : Literal [ True , False ] = True , d : ToolEnum = ToolEnum . hammer , e : HTTPEnum = HTTPEnum . not_found , ): print ( f \"a: { a } \" ) print ( f \"b: { b } \" ) print ( f \"c: { c } \" ) print ( f \"d: { d } \" ) print ( f \"e: { e } \" ) if __name__ == \"__main__\" : cli () Warning As you probably noticed, the string enumeration only subclasses Enum . Strictly speaking, ToolEnum(str, Enum) would be a better inheritance definition, however this breaks the type inference by providing two origins. Currently, there are two solutions: simply use Enum , it should be fine in most cases. use StrEnum , which however is only available since Python 3.11. Launching the help for this script will result in the following output: $ python choices.py --help > usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]] > > optional arguments: > -h, --help show this help message and exit > --a [one|two] (default: two) > --b [1|2] (default: 2) > --c [True|False] (default: True) > --d [hammer|screwdriver] (default: ToolEnum.hammer) > --e [ok|not_found|internal_error] (default: HTTPEnum.not_found) You can notice that, even without explicit description, choice-based fields will automatically provide the list of possible values. Defaults also behave as expected: both literals and enums will accept any of the allowed values as default, and it that case the selected item will be displayed as default in the console. Again, note that the CLI exploits the name field in enum-based arguments for readability, not its actual value. Calling the script with a wrong choice will result in an error message, displaying the list of allowed values: $ python choices.py --a three > usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]] > choices.py: error: argument --a: invalid choice: three (choose from [one|two]) Module types Note Coming soon!","title":"Field Types"},{"location":"guide/types/#field-types","text":"Thanks to features provided by pydantic 's data definitions, argdantic supports a large amount of field types, starting from the standard library up to JSON inputs.","title":"Field Types"},{"location":"guide/types/#primitive-types","text":"Considering primitive, non-complex data types, the library supports the following: str : values accepted as is, parsed as simple text without further processing. int : tries to convert any given input into an integer through int(value) . float : similarly, tries to convert any given input into a floating point number through float(value) . bytes : similar to strings, however in this case the underlying representation remains in bytes. bool : by default, booleans are intended as flag options. In this case any boolean field will have two corresponding CLI flags --field/--no-field . The following example shows a brief overview of the primitive types: primitives.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from argdantic import ArgParser cli = ArgParser () @cli . command () def status ( name : str , age : int , weight : float , data : bytes , flag : bool ): print ( f \"name: { name } \" ) print ( f \"age: { age } \" ) print ( f \"weight: { weight } \" ) print ( f \"data: { data } \" ) print ( f \"flag: { flag } \" ) if __name__ == \"__main__\" : cli () With the following help message: $ python primitives.py --help > usage: primitives.py [-h] --name TEXT --age INT --weight FLOAT --data BYTES (--flag | --no-flag) > > optional arguments: > -h, --help show this help message and exit > --name TEXT (required) > --age INT (required) > --weight FLOAT (required) > --data BYTES (required) > --flag > --no-flag Note Observe that the --flag and --no-flag options are not marked as required. That is the expected behaviour: strictly speaking, taken individually , they are not required. However, being mutually exclusive, one of either --flag or --no-flag is still needed. `argdantic`` takes care of converting the provided fields into argparse arguments, so that the automatically generated description reamins as faithful as possible. Bear in mind that types are exploited only for documentation purposes, the final type checking will be carried out by pydantic . Most complex types are often interpreted as strings, unless specified otherwise.","title":"Primitive types"},{"location":"guide/types/#complex-types","text":"Thanks to the powerful data definitions provided by pydantic , argdantic supports a large amount of complex types, Currently, the following types have been tested and supported:","title":"Complex types"},{"location":"guide/types/#standard-library-types","text":"Generally speaking, non-typed complex types will default to strings unless specified otherwise. list : without specifying the internal type, list fields will behave as multiple options of string items. Internally, argdantic exploits _argparse's nargs option to handle sequences. In this case, the argument can be repeated multiple times to build a list. For instance, python cli.py --add 1 2 will result in a list [1, 2] . tuple : similar to lists, this will behave as an unbounded sequence of strings, with multiple parameters. dict : dictionaries are interpreted as JSON strings. In this case, there will be no further validation. Given that valid JSON strings require double quotes, arguments provided through the command line must use single-quoted strings. For instance, python cli.py --extras '{\"items\": 12}' will be successfully parsed, while python cli.py --extras \"{'items': 12}\" will not. set : again, from a command line point of view, sets are a simple list of values. In this case, repeated values will be excluded. For instance, python cli.py --add a --add b --add a will result in a set {'a', 'b'} . frozenset : frozen sets adopt the same behavior as normal sets, with the only difference that they remain immutable. deque : similarly, deques act as sequences from a CLI standpoint, while being treaded as double-ended queues in code. range : ranges are interpreted as a sequence of integers, with the same behavior as lists and tuples.","title":"Standard Library types"},{"location":"guide/types/#typing-containers","text":"Any : For obvious reasons, Any fields will behave as str options without further processing. Optional : optional typing can be interpreted as syntactic sugar , meaning it will not have any effect on the underlying validation, but it provides an explicit declaration that the field can also accept None as value. List : Similar to standard lists, typing Lists behave as sequences of items. In this case however the inner type is exploited to provide further validation through pydantic . For instance, python cli.py --add a --add b will result in a validation error for a list of integers List[int] . Tuple : typing Tuples can behave in two ways: when using a variable length structure (i.e., Tuple[int] or Tuple[int, ...] ), tuples act as a sequence of typed items, validated through pydantic, where the parameter is specified multiple times. When using a _fixed length structure (i.e., Tuple[int, int] or similar), they are considered as fixed nargs options, where the parameter is specified once, followed by the sequence of values separated by whitespaces. For instance . python cli.py --items a b c will results in a tuple ('a', 'b', 'c') . If the items tuple specified only two items, the command will result in a validation error. Dict : Similar to the standard dict field, typing dictionaries require a JSON string as input. However, inner types allow for a finer validation: for instance, considering a metrics: Dict[str, float] field, --metrics '{\"f1\": 0.93}' is accepted, while --metrics '{\"auc\": \"a\"}' is not a valid input. Deque : with the same reasoning of typed lists and tuples, Deques will act as sequences with a specific type. Set : As you guessed, typed sets act as multiple options where repeated items are excluded, with additional type validation on the items themselves. FrozenSet : as with Sets , but they represent immutable structures after parsing. Sequence and Iterables : with no surpise, sequences and iterables act as sequences, nothing much to add here. Warning for obvious reasons, Union typings are not supported at this time. Parsing a multi-valued parameter is really more of a phylosophical problem than a technical one. Future releases will consider the support for this typing. The code below provides a relatively comprehensive view of most container types supported through argdantic . containers.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Deque , Dict , FrozenSet , List , Optional , Sequence , Set , Tuple from argdantic import ArgParser cli = ArgParser () @cli . command () def run ( simple_list : list , list_of_ints : List [ int ], simple_tuple : tuple , multi_typed_tuple : Tuple [ int , float , str , bool ], simple_dict : dict , dict_str_float : Dict [ str , float ], simple_set : set , set_bytes : Set [ bytes ], frozen_set : FrozenSet [ int ], none_or_str : Optional [ str ], sequence_of_ints : Sequence [ int ], compound : Dict [ str , List [ Set [ int ]]], deque : Deque [ int ], ): print ( f \"simple_list: { simple_list } \" ) print ( f \"list_of_ints: { list_of_ints } \" ) print ( f \"simple_tuple: { simple_tuple } \" ) print ( f \"multi_typed_tuple: { multi_typed_tuple } \" ) print ( f \"simple_dict: { simple_dict } \" ) print ( f \"dict_str_float: { dict_str_float } \" ) print ( f \"simple_set: { simple_set } \" ) print ( f \"set_bytes: { set_bytes } \" ) print ( f \"frozen_set: { frozen_set } \" ) print ( f \"none_or_str: { none_or_str } \" ) print ( f \"sequence_of_ints: { sequence_of_ints } \" ) print ( f \"compound: { compound } \" ) print ( f \"deque: { deque } \" ) if __name__ == \"__main__\" : cli () Executing this script with the help command will provide the description for the current configuration. Also, defaults are allowed and validated. $ python containers.py --help > usage: containers.py [-h] --simple-list TEXT [TEXT ...] --list-of-ints INT [INT ...] > --simple-tuple TEXT [TEXT ...] --multi-typed-tuple INT FLOAT TEXT BOOL --simple-dict JSON > --dict-str-float JSON --simple-set TEXT [TEXT ...] --set-bytes BYTES [BYTES ...] > --frozen-set INT [INT ...] --none-or-str TEXT --sequence-of-ints INT [INT ...] > --compound JSON --deque INT [INT ...] > > optional arguments: > -h, --help show this help message and exit > --simple-list TEXT [TEXT ...] (required) > --list-of-ints INT [INT ...] (required) > --simple-tuple TEXT [TEXT ...] (required) > --multi-typed-tuple INT FLOAT TEXT BOOL (required) > --simple-dict JSON (required) > --dict-str-float JSON (required) > --simple-set TEXT [TEXT ...] (required) > --set-bytes BYTES [BYTES ...] (required) > --frozen-set INT [INT ...] (required) > --none-or-str TEXT (required) > --sequence-of-ints INT [INT ...] (required) > --compound JSON (required) > --deque INT [INT ...] (required)","title":"Typing Containers"},{"location":"guide/types/#literals-and-enums","text":"Sometimes it may be useful to directly limit the choices of certain fields, by letting the user select among a fixed list of values. In this case, argdantic provides this feature using pydantic 's support for Enum and Literal types, parsed from the command line through the choice argument option. While Enums represent the standard way to provide choice-based options, Literals can be seen as a lightweight enumeration. In general, the latter are simpler and easier to handle than the former for most use cases. Enums on the other hand provide both a name and a value component, where only the former is exploited for the parameter definition. The latter can represent any kind of object, therefore making enums more suitable for more complex use cases. The following script presents a sample of possible choice definitions in clidantic : choices.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from enum import Enum , IntEnum from typing import Literal from argdantic import ArgParser cli = ArgParser () class ToolEnum ( Enum ): hammer = \"Hammer\" screwdriver = \"Screwdriver\" class HTTPEnum ( IntEnum ): ok = 200 not_found = 404 internal_error = 500 @cli . command () def run ( a : Literal [ \"one\" , \"two\" ] = \"two\" , b : Literal [ 1 , 2 ] = 2 , c : Literal [ True , False ] = True , d : ToolEnum = ToolEnum . hammer , e : HTTPEnum = HTTPEnum . not_found , ): print ( f \"a: { a } \" ) print ( f \"b: { b } \" ) print ( f \"c: { c } \" ) print ( f \"d: { d } \" ) print ( f \"e: { e } \" ) if __name__ == \"__main__\" : cli () Warning As you probably noticed, the string enumeration only subclasses Enum . Strictly speaking, ToolEnum(str, Enum) would be a better inheritance definition, however this breaks the type inference by providing two origins. Currently, there are two solutions: simply use Enum , it should be fine in most cases. use StrEnum , which however is only available since Python 3.11. Launching the help for this script will result in the following output: $ python choices.py --help > usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]] > > optional arguments: > -h, --help show this help message and exit > --a [one|two] (default: two) > --b [1|2] (default: 2) > --c [True|False] (default: True) > --d [hammer|screwdriver] (default: ToolEnum.hammer) > --e [ok|not_found|internal_error] (default: HTTPEnum.not_found) You can notice that, even without explicit description, choice-based fields will automatically provide the list of possible values. Defaults also behave as expected: both literals and enums will accept any of the allowed values as default, and it that case the selected item will be displayed as default in the console. Again, note that the CLI exploits the name field in enum-based arguments for readability, not its actual value. Calling the script with a wrong choice will result in an error message, displaying the list of allowed values: $ python choices.py --a three > usage: choices.py [-h] [--a [one|two]] [--b [1|2]] [--c [True|False]] [--d [hammer|screwdriver]] [--e [ok|not_found|internal_error]] > choices.py: error: argument --a: invalid choice: three (choose from [one|two])","title":"Literals and Enums"},{"location":"guide/types/#module-types","text":"Note Coming soon!","title":"Module types"}]}